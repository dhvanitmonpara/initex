import { randomUUID } from "node:crypto";
import { Request, Response } from "express";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import axios from "axios";
{{#if ts}}
import { env } from "@/common/config/env";
import { ApiError } from "@/common/utils/ApiError";
import generateDeviceFingerprint from "@/common/utils/generateDeviceFingerprint";
import nodeCache from "@/services/nodecache.service";
import { hashOTP } from "@/common/utils/cryptographer";
import * as authRepo from "@/adapters/auth.adapter";
{{else}}
import { env } from "../../common/config/env.js";
import { ApiError } from "../../common/utils/ApiError.js";
import generateDeviceFingerprint from "../../common/utils/generateDeviceFingerprint.js";
import prisma from "../../common/config/db.js";
import nodeCache from "./nodecache.service.js";
import { hashOTP } from "../../common/utils/cryptographer.js";
import * as authRepo from "../../adapters/auth.adapter.js";
{{/if}}

class AuthService {
  options{{#if ts}}: null | {
    httpOnly: boolean;
    secure: boolean;
    sameSite: "none" | "lax";
    domain?: string;
  }{{/if}} = null;
  accessTokenExpiry = 60 * 1000 * parseInt(env.ACCESS_TOKEN_LIFE || "0"); // In minutes
  refreshTokenExpiry =
    60 * 60 * 1000 * 24 * parseInt(env.REFRESH_TOKEN_LIFE || "0"); // In days

  constructor() {
    this.options = {
      httpOnly: true,
      secure: env.NODE_ENV === "production",
      ...(env.NODE_ENV === "production" ? {} : { domain: "localhost" }),
      sameSite:
        env.NODE_ENV === "production"
        {{#if ts}}
          ? ("none" as "none")
          : ("lax" as "lax"),
        {{else}}
          ? "none"
          : "lax",
        {{/if}}
    };
  }

  async generateUuidBasedUsername(
    length = 12
  ) {
    const maxTries = 20;

    for (let i = 0; i < maxTries; i++) {
      const uuid = randomUUID().replace(/-/g, "").slice(0, length);

      const exists = await authRepo.findByUsername(uuid);
      if (!exists) {
        return uuid;
      }
    }

    // Fallback username in case of failure
    const fallbackUsername = `User${Date.now()}${Math.floor(
      Math.random() * 1000
    )}`;
    return fallbackUsername;
  }

  generateAccessToken({{#if ts}}id: string{{#if useMongodb}} | Types.ObjectId{{/if}}, username: string{{else}}id, username{{/if}}) {
    return jwt.sign(
      {
        id,
        username,
      },
      env.ACCESS_TOKEN_SECRET,
      {
        expiresIn: `${parseInt(env.ACCESS_TOKEN_LIFE || "0")}m`,
      }
    );
  }

  generateRefreshToken({{#if ts}}id: string{{#if useMongodb}} | Types.ObjectId{{/if}}, username: string{{else}}id, username{{/if}}) {
    return jwt.sign(
      {
        id,
        username,
      },
      env.REFRESH_TOKEN_SECRET,
      {
        expiresIn: `${parseInt(env.REFRESH_TOKEN_LIFE || "0")}d`,
      }
    );
  }

  async generateAccessAndRefreshToken({{#if ts}}userId: string{{#if useMongodb}} | Types.ObjectId{{/if}}, req: Request{{else}}userId, req{{/if}}) {
    const user = await authRepo.findById(userId);

    if (!user)
      throw new ApiError({
        statusCode: 404,
        message: "User not found",
        data: { service: "authService.generateAccessAndRefreshToken" },
      });

    const accessToken = this.generateAccessToken(user.{{#if useMongodb}}_id{{else}}id{{/if}}, user.username);
    const refreshToken = this.generateRefreshToken(user.{{#if useMongodb}}_id{{else}}id{{/if}}, user.username);

    const userAgent = await generateDeviceFingerprint(req);
    const rawIp =
      req.headers["cf-connecting-ip"] ||
      req.headers["x-forwarded-for"] ||
      req.ip;

    const ip = (Array.isArray(rawIp) ? rawIp[0] : rawIp || "")
      .split(",")[0]
      .trim();

    await authRepo.updateRefreshToken(user, refreshToken);

    return { accessToken, refreshToken, userAgent, ip };
  }

  setAuthCookies = (
    {{#if ts}}
    res: Response,
    accessToken: string,
    refreshToken: string
    {{else}}res, accessToken, refreshToken{{/if}}
  ) => {
    res
      .cookie("accessToken", accessToken, {
        ...authService.options,
        maxAge: authService.accessTokenExpiry,
      })
      .cookie("refreshToken", refreshToken, {
        ...authService.options,
        maxAge: authService.refreshTokenExpiry,
      });
  };

  handleGoogleOAuth = async ({{#if ts}}code: string, req: Request{{else}}code, req{{/if}}) => {
    // 1. Exchange code for access token
    const { data } = await axios.post(
      "https://oauth2.googleapis.com/token",
      null,
      {
        params: {
          code,
          client_id: env.GOOGLE_OAUTH_CLIENT_ID,
          client_secret: env.GOOGLE_OAUTH_CLIENT_SECRET,
          redirect_uri: `${env.SERVER_BASE_URI}/api/v1/users/google/callback`,
          grant_type: "authorization_code",
        },
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
      }
    );

    const { access_token } = data;

    // 2. Get user info
    const userInfoRes = await axios.get(
      "https://www.googleapis.com/oauth2/v2/userinfo",
      { headers: { Authorization: `Bearer ${access_token}` } }
    );

    const user = userInfoRes.data;

    // 3. Check existing user
    const existingUser = await authRepo.findByEmail(user.email);

    let redirectUrl{{#if ts}}: string{{/if}};

    if (existingUser) {
      const { accessToken, refreshToken } =
        await this.generateAccessAndRefreshToken(existingUser.{{#if useMongodb}}_id{{else}}id{{/if}}, req);

      const tempToken = crypto.randomUUID();
      nodeCache.set(tempToken, {
        accessToken,
        refreshToken,
        createdAt: Date.now(),
      });

      redirectUrl = `${env.ACCESS_CONTROL_ORIGIN}/auth/oauth/signin?tempToken=${tempToken}`;
    } else {
      redirectUrl = `${env.ACCESS_CONTROL_ORIGIN}/auth/oauth/callback?email=${user.email}`;
    }

    return { redirectUrl };
  };

  handleUserOAuth = async ({{#if ts}}email: string, username: string, req: Request{{else}}email, username, req{{/if}}) => {
    const createdUser = await authRepo.create({ 
      email, 
      username, 
      authType: "oauth", 
      password: null
    });

    if (!createdUser)
      throw new ApiError({
        statusCode: 500,
        message: "Failed to create user",
        data: { service: "authService.handleUserOAuth" },
      });

    const { accessToken, refreshToken } =
      await authService.generateAccessAndRefreshToken(createdUser.{{#if useMongodb}}_id{{else}}id{{/if}}, req);

    if (!accessToken || !refreshToken) {
      throw new ApiError({
        statusCode: 500,
        message: "Failed to generate access and refresh token",
        code: "INTERNAL_SERVER_ERROR",
        data: { service: "authService.handleUserOAuth" },
      });
    }

    return {
      createdUser,
      accessToken,
      refreshToken,
    };
  };

  redeemTempToken = (tempToken{{#if ts}}: string{{/if}}) => {
    const stored{{#if ts}}: { accessToken: string; refreshToken: string } | undefined{{/if}} =
      nodeCache.get(tempToken);

    if (!stored) return null;

    nodeCache.del(tempToken);

    return stored;
  };

  initializeAuthService = async (
    {{#if ts}}
    email: string,
    username: string,
    password: string
    {{else}}email, username, password{{/if}}
  ) => {
    const existingUser = await authRepo.findByEmail(email);

    if (existingUser)
      throw new ApiError({
        statusCode: 400,
        message: "User with this email already exists",
        data: { service: "authService.initializeAuthService" },
      });

    const usernameTaken = await authRepo.findByUsername(username);    
    if (usernameTaken)
      throw new ApiError({
        statusCode: 400,
        message: "Username is already taken",
        data: { service: "authService.initializeAuthService" },
      });

    const user = { email: email.toLowerCase(), username, password };

    const cacheSuccess = nodeCache.set(`pending:${email}`, user, 300);
    if (!cacheSuccess)
      throw new ApiError({
        statusCode: 500,
        message: "Failed to set user in cache",
        data: { service: "authService.initializeAuthService" },
      });

    return email;
  };

  registerAuthService = async ({{#if ts}}email: string, req: Request{{else}}email, req{{/if}}) => {
    const user = nodeCache.get(`pending:${email}`);
    if (!user)
      throw new ApiError({
        statusCode: 400,
        message: "User not found",
        data: { service: "authService.registerAuthService" },
      });

    const { password, username } = user{{#if ts}} as {
      password: string;
      username: string;
    }{{/if}};

    const encryptedPassword = await bcrypt.hash(password, 12);

    const createdUser = await authRepo.create({
      email,
      password: encryptedPassword,
      username,
      authType: "manual",
    });

    const { accessToken, refreshToken } =
      await this.generateAccessAndRefreshToken(createdUser.{{#if useMongodb}}_id{{else}}id{{/if}}, req);

    if (!accessToken || !refreshToken)
      throw new ApiError({
        statusCode: 500,
        message: "Failed to generate access and refresh token",
        data: { service: "authService.registerAuthService" },
      });

    // Cleanup cache
    nodeCache.del(`pending:${email}`);
    nodeCache.del(`otp:${email}`);

    return { createdUser, accessToken, refreshToken };
  };

  loginAuthService = async ({{#if ts}}email: string, password: string, req: Request{{else}}email, password, req{{/if}}) => {
    const user = await authRepo.findByEmail(email);

    if (!user)
      throw new ApiError({
        statusCode: 400,
        message: "User not found",
        data: { service: "authService.loginAuthService" },
      });
    if (!user.password)
      throw new ApiError({
        statusCode: 400,
        message: "Password not set",
        data: { service: "authService.loginAuthService" },
      });

    const passwordValid = await bcrypt.compare(password, user.password);
    if (!passwordValid)
      throw new ApiError({
        statusCode: 400,
        message: "Invalid password",
        data: { service: "authService.loginAuthService" },
      });

    const { accessToken, refreshToken, userAgent, ip } =
      await authService.generateAccessAndRefreshToken(user.{{#if useMongodb}}_id{{else}}id{{/if}}, req);

    return { user, accessToken, refreshToken };
  };

  logoutAuthService = async (userId{{#if ts}}: string{{/if}}) => {
    const user = await authRepo.findById(userId);
    if (!user)
      throw new ApiError({
        statusCode: 400,
        message: "User not found",
        data: { service: "authService.logoutAuthService" },
      });

    await authRepo.updateRefreshToken(user, "");
  };

  clearAuthCookies = (res{{#if ts}}: Response{{/if}}) => {
    res
      .clearCookie("accessToken", { ...authService.options, maxAge: 0 })
      .clearCookie("refreshToken", { ...authService.options, maxAge: 0 });
  };

  getUserByIdService = async (userId{{#if ts}}: string{{/if}}) => {
    const user = await authRepo.findById(userId);

    if (!user)
      throw new ApiError({
        statusCode: 404,
        message: "User doesn't exists",
        data: { service: "authService.getUserByIdService" },
      });

    return user;
  };

  refreshAccessTokenService = async (
    {{#if ts}}
    incomingRefreshToken: string,
    req: Request
    {{else}}incomingRefreshToken, req{{/if}}
  ) => {
    if (!incomingRefreshToken)
      throw new ApiError({
        statusCode: 401,
        message: "Unauthorized request",
        data: { service: "authService.refreshAccessTokenService" },
      });

    const decodedToken = jwt.verify(
      incomingRefreshToken,
      env.REFRESH_TOKEN_SECRET
    );
    if (!decodedToken || typeof decodedToken === "string")
      throw new ApiError({
        statusCode: 401,
        message: "Invalid Access Token",
        data: { service: "authService.refreshAccessTokenService" },
      });

    const user = await authRepo.findById(decodedToken.{{#if useMongodb}}_id{{else}}id{{/if}});

    if (!user || !user.refreshToken)
      throw new ApiError({
        statusCode: 401,
        message: "Invalid Refresh Token",
        data: { service: "authService.refreshAccessTokenService" },
      });

    if (!user.refreshToken.includes(incomingRefreshToken))
      throw new ApiError({
        statusCode: 401,
        message: "Refresh token is invalid or not recognized",
        data: { service: "authService.refreshAccessTokenService" },
      });

    const { accessToken, refreshToken } =
      await authService.generateAccessAndRefreshToken(user.{{#if useMongodb}}_id{{else}}id{{/if}}, req);

    return { accessToken, refreshToken };
  };

  sendOtpService = async (email{{#if ts}}: string{{/if}}) => {
    const mailResponse = await axios.post(
      "https://simple-smtp-service.vercel.app/api/v1/mail",
      {
        to: email,
        type: "OTP",
        options: { from: `"{{name}}" <no-reply@{{name}}.com>` },
      },
      {
        headers: {
          "x-api-token": env.SMTP_API_TOKEN,
          "Content-Type": "application/json",
        },
      }
    );

    const data = mailResponse.data?.data;
    if (!data?.success || !data?.details?.otp)
      throw new ApiError({
        statusCode: 500,
        message: "Failed to send OTP",
        data: { service: "authService.sendOtpService" },
      });

    const hashedOTP = await hashOTP(data.details.otp);

    const cacheSuccess = nodeCache.set(`otp:${email}`, hashedOTP, 65);
    if (!cacheSuccess)
      throw new ApiError({
        statusCode: 500,
        message: "Failed to set OTP in cache",
        data: { service: "authService.sendOtpService" },
      });

    return { otp: data.details.otp, messageId: data.messageId };
  };

  compareOTP = async ({{#if ts}}email: string, otp: string{{else}}email, otp{{/if}}) => {
    try {
      const storedOtp = nodeCache.get(`otp:${email}`);

      const hashedOTP = await hashOTP(otp);

      if (storedOtp === hashedOTP) {
        nodeCache.del(`otp:${email}`);
        return true;
      } else {
        return false;
      }
    } catch {
      return false;
    }
  };

  verifyOtpService = async {{#if ts}}(email: string, otp: string): Promise<boolean>{{else}}(email, otp){{/if}} => {
    if (!email || !otp)
      throw new ApiError({
        statusCode: 400,
        message: "Email and OTP are required",
        data: { service: "authService.verifyOtpService" },
      });

    const cachedOtp = nodeCache.get<string>(`otp:${email}`);
    if (!cachedOtp) return false;

    const isValid = await this.compareOTP(email, otp);
    if (isValid) nodeCache.del(`otp:${email}`);

    return isValid;
  };

  searchUsersService = async (query{{#if ts}}: string{{/if}}) => {
    if (!query)
      throw new ApiError({
        statusCode: 400,
        message: "Query is required",
        data: { service: "authService.searchUsersService" },
      });

    const users = await authRepo.searchUsers(query);

    return users;
  };
}

const authService = new AuthService();
export default authService;
